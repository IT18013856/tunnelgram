<div class="position-absolute h-100 w-100 pt-3" style="overflow-y: auto;" ref:container on:scroll="handleScroll()">
  {#if _loading}
    <div class="d-flex align-items-center justify-content-center" style="height: 200px;">
      <div class="col-auto">
        <LoadingIndicator width="50px" height="50px" />
      </div>
    </div>
  {:else}
    <div class="d-flex flex-column align-items-start" ref:messageContainer>
      <div class="align-self-stretch text-center">
        <h1>{name}</h1>
        <p>
          Started {moment.unix($conversation.cdate).format('llll')}
        </p>
      </div>
      {#if _loadingEarlierMessages}
        <div class="d-flex align-items-center justify-content-center align-self-stretch" style="height: 200px;">
          <div class="col-auto">
            <LoadingIndicator width="50px" height="50px" />
          </div>
        </div>
      {/if}
      {#each messages as message (message.guid)}
        <MessageView bind:message on:deleted="removeMessage(message)" readLineCDate="{_showReadline && _initialReadline}"></MessageView>
      {/each}
    </div>
  {/if}
</div>

<script>
  import {Nymph, PubSub} from 'nymph-client';
  import Message from '../Entities/Message';
  import LoadingIndicator from './LoadingIndicator.html';
  import MessageView from './MessageView.html';
  import ErrHandler from '../ErrHandler';
  import moment from 'moment';

  export default {
    oncreate () {
      this.subscribe();
      const {conversation} = this.store.get();
      this.set({
        _initialReadline: conversation.readline,
        _latestReadline: conversation.readline
      });
    },

    onstate ({changed, current}) {
      const {_showReadline, _initialReadline, messages} = current;
      if (_showReadline === null && _initialReadline !== 0 && messages.length) {
        this.set({
          _showReadline: _initialReadline > 0
            && _initialReadline < messages[messages.length - 1].cdate
        });
      }
    },

    onupdate ({changed, current}) {
      if (changed._loadingEarlierMessages) {
        this.refs.container.scrollTop += 200 * (current._loadingEarlierMessages ? 1 : -1);
      }

      if (changed._scrollToDistanceFromBottom && current._scrollToDistanceFromBottom != null) {
        window.requestAnimationFrame(() => {
          this.refs.container.scrollTop = this.refs.container.scrollHeight - current._scrollToDistanceFromBottom;
        });
      }
    },

    ondestroy () {
      let {_subscription} = this.get();
      if (_subscription) {
        _subscription.unsubscribe();
      }
    },

    computed: {
      name: ({$conversation, $user}) => $conversation.getName($user)
    },

    data () {
      return {
        _isAtBottom: true,
        _showReadline: null,
        _initialReadline: null,
        _latestReadline: null,
        _reachedEarliestMessage: false,
        _scrollToDistanceFromBottom: null,
        messages: []
      };
    },

    methods: {
      subscribe () {
        let {_subscription} = this.get();
        if (_subscription) {
          _subscription.unsubscribe();
        }

        this.set({_loading: true});

        const {conversation} = this.store.get();
        _subscription = Nymph.getEntities({
          'class': Message.class,
          'sort': 'cdate',
          'reverse': true,
          'limit': 20
        }, {
          'type': '&',
          'ref': ['conversation', conversation.guid]
        }).subscribe(update => {
          this.set({_loading: false});
          if (update) {
            const {messages} = this.get();
            PubSub.updateArray(messages, update);
            Nymph.sort(messages, 'cdate');
            this.set({messages});
            this.createNewReadlineIfNeeded();
            this.handleNewMessageScroll();
          }
        }, ErrHandler);
        this.set({_subscription});
      },

      handleScroll () {
        if (this.refs.container.scrollTop < 100) {
          this.loadEarlierMessages();
        }

        this.set({_isAtBottom: this.refs.container.scrollTop >= (this.refs.container.scrollHeight - this.refs.container.offsetHeight)});
        this.updateReadline();
      },

      handleNewMessageScroll () {
        if (this.get()._isAtBottom) {
          this.scrollToBottom();
          this.updateReadline();
        }
      },

      async loadEarlierMessages () {
        if (this.get()._loadingEarlierMessages || this.get()._reachedEarliestMessage) {
          return;
        }

        const {messages} = this.get();
        const {conversation} = this.store.get();

        if (!messages.length) {
          return;
        }

        this.set({_loadingEarlierMessages: true});

        try {
          const earlierMessages = await Nymph.getEntities({
            'class': Message.class,
            'sort': 'cdate',
            'reverse': true,
            'limit': 20
          }, {
            'type': '&',
            'ref': ['conversation', conversation.guid],
            'lt': ['cdate', messages[0].cdate]
          });

          if (earlierMessages.length) {
            const distanceFromBottom = this.refs.container.scrollHeight - this.refs.container.scrollTop;
            Nymph.sort(earlierMessages, 'cdate');
            this.set({messages: [...earlierMessages, ...messages], _scrollToDistanceFromBottom: distanceFromBottom});
          } else {
            this.set({_reachedEarliestMessage: true});
          }
        } catch (e) {
          ErrHandler(e);
        }

        this.set({_loadingEarlierMessages: false});
      },

      updateReadline () {
        // Update readline.
        const {_latestReadline} = this.get();
        if (_latestReadline !== null) {
          const messageEls = this.refs.messageContainer.querySelectorAll('.message[data-cdate]');
          const messageElsInViewport = Array.from(messageEls).filter((el) => {
              const containerTop = this.refs.container.scrollTop;
              const containerBottom = containerTop + this.refs.container.clientHeight;
              const elBottom = el.offsetTop + el.offsetHeight;
              return (elBottom >= containerTop)
                     && (elBottom <= containerBottom);
          });
          if (messageElsInViewport.length) {
            const latestReadMessageEl = messageElsInViewport[messageElsInViewport.length - 1];
            const updateReadline = parseFloat(latestReadMessageEl.dataset.cdate);
            if (updateReadline > _latestReadline) {
              this.set({_latestReadline: updateReadline});
              const {conversation} = this.store.get();
              conversation.saveReadline(updateReadline);
            }
          }
        }
      },

      createNewReadlineIfNeeded () {
        const {conversation} = this.store.get();
        const {messages} = this.get();
        if (conversation.readline == null && messages.length) {
          const updateReadline = messages[messages.length - 1].cdate;
          this.set({
            _initialReadline: updateReadline,
            _latestReadline: updateReadline
          });
          conversation.saveReadline(updateReadline);
        }
      },

      scrollToBottom () {
        this.refs.container.scrollTop = this.refs.container.scrollHeight;
      },

      removeMessage (message) {
        const {messages} = this.get();
        const index = message.arraySearch(messages);
        if (index !== false) {
          messages.splice(index, 1);
          this.set({messages});
        }
      }
    },

    components: {
      LoadingIndicator,
      MessageView
    },

    helpers: {
      moment
    }
  };
</script>
