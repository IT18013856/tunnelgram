<div class="position-absolute h-100 w-100 pt-3" style="overflow-y: auto;" ref:container on:scroll="handleScroll()">
  {#if _loading}
    <div class="d-flex align-items-center justify-content-center" style="height: 200px;">
      <div class="col-auto">
        <LoadingIndicator width="50px" height="50px" />
      </div>
    </div>
  {:else}
    <div class="d-flex flex-column align-items-start" ref:messageContainer>
      <div class="align-self-stretch text-center">
        <h1>{name}</h1>
        <p>
          Started {moment.unix($conversation.cdate).format('llll')}
        </p>
      </div>
      {#each messages as message (message.guid)}
        <MessageView bind:message readLineCDate="{_showReadline && _initialReadline}"></MessageView>
      {/each}
    </div>
  {/if}
</div>

<script>
  import {Nymph, PubSub} from 'nymph-client';
  import Message from '../Entities/Message';
  import LoadingIndicator from './LoadingIndicator.html';
  import MessageView from './MessageView.html';
  import ErrHandler from '../ErrHandler';
  import moment from 'moment';

  export default {
    oncreate () {
      this.subscribe();
      const {conversation} = this.store.get();
      this.set({
        _initialReadline: conversation.readline,
        _latestReadline: conversation.readline
      });
    },

    onstate ({changed, current}) {
      const {_showReadline, _initialReadline, messages} = current;
      if (_showReadline === null && _initialReadline !== 0 && messages.length) {
        this.set({
          _showReadline: _initialReadline > 0
            && _initialReadline < messages[messages.length - 1].cdate
        });
      }
    },

    ondestroy () {
      let {_subscription} = this.get();
      if (_subscription) {
        _subscription.unsubscribe();
      }
    },

    computed: {
      name: ({$conversation, $user}) => $conversation.getName($user)
    },

    data () {
      return {
        _isAtBottom: true,
        _showReadline: null,
        _initialReadline: null,
        _latestReadline: null,
        messages: []
      };
    },

    methods: {
      subscribe () {
        let {_subscription} = this.get();
        if (_subscription) {
          _subscription.unsubscribe();
        }

        this.set({_loading: true});

        const {conversation} = this.store.get();
        _subscription = Nymph.getEntities(
            {'class': Message.class},
            {
              'type': '&',
              'ref': ['conversation', conversation.guid]
            }
        ).subscribe(update => {
          this.set({_loading: false});
          if (update) {
            const {messages} = this.get();
            PubSub.updateArray(messages, update);
            Nymph.sort(messages, 'cdate');
            this.set({messages});
            this.handleNewMessageScroll();
          }
        }, ErrHandler);
        this.set({_subscription});
      },

      handleScroll () {
        this.set({_isAtBottom: this.refs.container.scrollTop >= (this.refs.container.scrollHeight - this.refs.container.offsetHeight)});
        this.updateReadline();
      },

      handleNewMessageScroll () {
        if (this.get()._isAtBottom) {
          this.scrollToBottom();
          this.updateReadline();
        }
      },

      updateReadline () {
        // Update readline.
        const {_latestReadline} = this.get();
        if (_latestReadline !== null) {
          const messageEls = this.refs.messageContainer.querySelectorAll('.message[data-cdate]');
          const messageElsInViewport = Array.from(messageEls).filter((el) => {
              const containerTop = this.refs.container.scrollTop;
              const containerBottom = containerTop + this.refs.container.clientHeight;
              const elBottom = el.offsetTop + el.offsetHeight;
              return (elBottom >= containerTop)
                     && (elBottom <= containerBottom);
          });
          if (messageElsInViewport.length) {
            const latestReadMessageEl = messageElsInViewport[messageElsInViewport.length - 1];
            const updateReadline = parseFloat(latestReadMessageEl.dataset.cdate);
            if (updateReadline > _latestReadline) {
              this.set({_latestReadline: updateReadline});
              const {conversation} = this.store.get();
              conversation.saveReadline(updateReadline);
            }
          }
        }
      },

      scrollToBottom () {
        this.refs.container.scrollTop = this.refs.container.scrollHeight;
      }
    },

    components: {
      LoadingIndicator,
      MessageView
    },

    helpers: {
      moment
    }
  };
</script>
