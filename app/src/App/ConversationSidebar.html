<div class="d-flex w-100 justify-content-between align-items-start">
  <h5 class="mb-0">{name}</h5>
  <small class="ml-1" title="{moment.unix(conversation.mdate).format('llll')}" style="white-space: nowrap;">{modifiedDate}</small>
</div>
<div class="d-flex w-100 mt-1 justify-content-between align-items-end">
  {#if conversation.data.lastMessage}
    <small ref:lastmessage>
      {#if conversation.data.lastMessage.decrypted.text != null}
        {conversation.data.lastMessage.decrypted.text}
      {:elseif conversation.data.lastMessage.decrypted.images.length === 1}
        [A photo]
      {:elseif conversation.data.lastMessage.decrypted.images.length > 1}
        [Photos]
      {/if}
    </small>
  {:else}
    <span>&nbsp;</span>
  {/if}
  {#await _unreadCount}
    <span>&nbsp;</span>
  {:then count}
    {#if count === 0}
      <span>&nbsp;</span>
    {:elseif count === true}
      <span class="badge badge-primary">New</span>
    {:else}
      <span class="badge badge-primary">{count}</span>
    {/if}
  {:catch e}
    <span>&nbsp;</span>
  {/await}
</div>

<script>
  import Conversation from '../Entities/Conversation';
  import ErrHandler from '../ErrHandler';
  import moment from 'moment';

  export default {
    oncreate () {
      this.interval = window.setInterval(this.updateTime.bind(this), 10000);
      this.updateTime();

      this.store.on('state', ({changed}) => {
        if (changed.conversations && this.get()._readline < this.get().conversation.readline) {
          this.set({
            _unreadCount: this.get().conversation.unreadCount(),
            _readline: this.get().conversation.readline
          });
        }
      });
    },

    onstate ({changed, current}) {
      if (changed.conversation && current.conversation) {
        const {conversation} = current;
        if (conversation.data.user.isASleepingReference) {
          conversation.readyAll(() => this.set({conversation}), ErrHandler, 1);
          this.updateTime();
        }

        this.set({
          _unreadCount: current.conversation.unreadCount(),
          _readline: current.conversation.readline
        });
      }
    },

		ondestroy() {
			clearInterval(this.interval);
		},

    data () {
      return {
        _readline: 0,
        _unreadCount: new Promise(() => {}),
        conversation: new Conversation()
      }
    },

    computed: {
      name: ({conversation, $user}) => conversation.getName($user),
      isOwner: ({conversation, $user}) => $user.is(conversation.data.user)
    },

    methods: {
      save () {
        this.get().conversation.save().then(() => {}, ErrHandler);
      },

      updateTime () {
        this.set({modifiedDate: moment(new Date(Math.min(this.get().conversation.mdate * 1000, new Date()))).fromNow(true)});
      }
    },

    helpers: {
      moment
    }
  };
</script>

<style>
  ref:lastmessage {
    max-width: 100%;
    display: inline-block;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
</style>
