<div class="d-flex w-100 justify-content-center align-items-center">
  <div class="d-flex justify-content-center align-items-center flex-wrap" style="width: 60px; height: 60px;">
    {#each avatarUsersAndWidth.users as user (user.guid)}
      <Avatar bind:user size={avatarUsersAndWidth.width} />
    {/each}
  </div>
  <div class="pl-2" style="width: calc(100% - 60px);">
    <div class="d-flex w-100 justify-content-between align-items-start">
      <h5 class="mb-0" style="word-break: break-word;">{conversation.getName($settings)}</h5>
      <small class="ml-1" title={_longModifiedDate} style="white-space: nowrap;">{_modifiedDate}</small>
    </div>
    <div class="d-flex w-100 justify-content-between align-items-end">
      {#if conversation.data.lastMessage}
        <small class="last-message">
          {#if conversation.data.lastMessage.decrypted.text != null}
            {conversation.data.lastMessage.decrypted.text}
          {:else if conversation.data.lastMessage.decrypted.images.length === 1}
            [A photo]
          {:else if conversation.data.lastMessage.decrypted.images.length > 1}
            [Photos]
          {:else if conversation.data.lastMessage.decrypted.video !== null}
            [A video]
          {/if}
        </small>
      {:else}
        <span>&nbsp;</span>
      {/if}
      {#if _unreadCount === 0}
        <span>&nbsp;</span>
      {:else}
        <span class="badge badge-primary">{_unreadCount === true ? 'New' : _unreadCount}</span>
      {/if}
    </div>
  </div>
</div>

<script>
  import {onMount, onDestroy} from 'svelte';
  import Avatar from '../Users/Avatar';
  import Conversation from '../../Entities/Tunnelgram/Conversation';
  import {SimpleDateFormatter} from '../../Services/SimpleDateFormatter';
  import ErrHandler from '../../ErrHandler';
  import {settings, user} from '../../stores';

  export let conversation = new Conversation();
  let _unreadCount = 0;
  let _modifiedDate;
  let _longModifiedDate;
  let interval;
  let destroyed = false;

  $: isOwner = $user.is(conversation.data.user);
  $: avatarUsersAndWidth = (() => {
    let users;
    if (!conversation.data.acFull) {
      users = [];
    } else if (conversation.data.acFull.length === 1) {
      users = conversation.data.acFull;
    } else {
      users = conversation.data.acFull.filter(u => !$user.is(u));
    }
    let i = 1;
    while (i**2 < users.length) {
      i++;
    }
    const width = Math.floor(60 / i);
    return {users, width};
  })();

  $: if (conversation) {
    updateTime();
    (async () => {
      _unreadCount = await conversation.unreadCount();
    })();
  }

  $: if (conversation && conversation.containsSleepingReference && !conversation._tgCalledReadyAll) {
    // Ready the conversation's referenced entities.
    if (conversation.containsSleepingReference && !conversation._tgCalledReadyAll) {
      conversation._tgCalledReadyAll = true;
      conversation.readyAll(1).then(() => {
        conversation.containsSleepingReference = false;
        conversation._tgCalledReadyAll = false;
        if (!destroyed) {
          conversation = conversation;
        }
      }, ErrHandler);
    }
  }

  onMount(() => {
    interval = window.setInterval(() => updateTime(), 10000);
    updateTime();
  });

  onDestroy(() => {
    destroyed = true;
    if (interval) {
      clearInterval(interval);
    }
  });

  function updateTime () {
    _modifiedDate = new SimpleDateFormatter(Math.min(conversation.mdate, (+new Date()) / 100)).format('ago', 'short');
    _longModifiedDate = new SimpleDateFormatter(conversation.mdate).format('wymdhms', 'short');
  }
</script>

<style>
  .last-message {
    max-width: 100%;
    display: inline-block;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
</style>
