<div class="d-flex flex-column h-100 position-relative" on:dragover="handleDrag(event, true)">
  {#if _showDropbox}
    <div class="position-absolute w-100 h-100" style="z-index: 200;" on:dragleave="handleDrag(event, false)" on:drop="handleDrop(event)"></div>
    <div class="d-flex justify-content-center align-items-center position-absolute w-100 h-100 bg-white" style="opacity: .9; z-index: 100;">
      <div class="d-flex flex-column justify-content-center align-items-center">
        <span class="fa-layers fa-fw fa-5x">
          <i class="fas fa-file"></i>
          <i class="fa-inverse fas fa-plus" data-fa-transform="shrink-10"></i>
        </span>

        <div class="h1 mt-2">
          Drop files to upload to conversation.
        </div>
      </div>
    </div>
  {/if}
  <div class="flex-grow-1  position-relative">
    <MessageList ref:messageList />
  </div>
  <form on:submit="newMessage(event.preventDefault())">
    {#if images.length || video != null || _imagesLoading}
      <div class="d-flex flex-wrap justify-content-start align-items-start bg-secondary pt-2 pl-2">
        {#each images as image, i}
          <div class="d-flex justify-content-center align-items-center mr-2 mb-2 border border-light position-relative" style="width: 152px; height: 152px;">
            <img src="{image.thumbnailImg}" alt="{image.name}" title="{image.name}" />
            <button type="button" class="btn btn-sm btn-danger rounded-circle position-absolute" style="opacity: .8; right: 4px; top: 4px;" on:click="set({images: removeIndex(images, i)})">
              <i class="fas fa-times text-white d-inline-block" style="width: 1em; height: 1em;"></i>
            </button>
            <span class="badge badge-light position-absolute" style="opacity: .8; left: 4px; bottom: 4px; pointer-events: none;">
              {image.dataWidth}x{image.dataHeight}
            </span>
            <span class="badge badge-light position-absolute" style="opacity: .8; right: 4px; bottom: 4px; pointer-events: none;">
              {round(image.data.length / 1024 / 1024, 1)}MB
            </span>
          </div>
        {/each}
        {#if video != null}
          <div class="d-flex justify-content-center align-items-center mr-auto ml-auto mb-2 border border-light position-relative" style="min-width: 152px; min-height: 152px;">
            <video poster="{video.thumbnailImg}" width="{video.thumbnailWidth}" height="{video.thumbnailHeight}" title="{video.name}" controls>
              <source src="{video.objectURL}" type="{video.dataType}" />
            </video>
            <button type="button" class="btn btn-sm btn-danger rounded-circle position-absolute" style="opacity: .8; right: 4px; top: 4px;" on:click="set({video: null})">
              <i class="fas fa-times text-white d-inline-block" style="width: 1em; height: 1em;"></i>
            </button>
            <span class="badge badge-light position-absolute" style="opacity: .8; left: 4px; bottom: 4px; pointer-events: none;">
              {video.dataWidth}x{video.dataHeight} - {floor(video.dataDuration / (60 * 60))}:{floor((video.dataDuration % (60 * 60)) / 60)}:{floor(video.dataDuration % 60)}
            </span>
            <span class="badge badge-light position-absolute" style="opacity: .8; right: 4px; bottom: 4px; pointer-events: none;">
              {round(video.data.length / 1024 / 1024, 1)}MB
            </span>
          </div>
        {/if}
        {#if _imagesLoading}
          <div class="d-flex justify-content-center align-items-center text-white mr-2 mb-2" style="width: 152px; height: 152px;">
            <LoadingIndicator width="50px" height="50px" text="Resampling..." />
          </div>
        {/if}
      </div>
    {/if}
    <div class="d-flex align-items-stretch">
      <input class="d-none" type="file" ref:fileInput on:change="handleFiles(event.target.files)" accept="image/*, video/webm, video/mp4" multiple>
      <button class="btn btn-lg btn-info p-0 d-inline-flex justify-content-center align-items-center" style="width: 60px; min-width: 60px; font-size: .8em;" type="button" on:click="refs.fileInput.click()" title="Add picture/video"><i class="fas fa-camera"></i>&nbsp;/&nbsp;<i class="fas fa-video"></i></button>
      <textarea class="form-control border-primary border-top text-dark" bind:value="text" placeholder="New message" on:keydown="handleKeyDown(event)" on:keyup="handleKeyUp()" ref:textEditor></textarea>
      <button class="btn btn-lg btn-primary" style="width: 60px; min-width: 60px;" type="submit" disabled="{messageIsEmpty}" title="Send message"><i class="fas fa-comment"></i></button>
    </div>
  </form>
</div>

<script>
  import emoji from 'node-emoji';
  import PNotify from 'pnotify/dist/es/PNotify';
  import Message from '../../Entities/Message';
  import MessageList from '../Messages/MessageList.html';
  import LoadingIndicator from '../LoadingIndicator.html';
  import {crypt} from '../../Services/EncryptionService';
  import ResizeImage from '../../Services/ResizeImage';
  import ErrHandler from '../../ErrHandler';

  const mobile = (() => {
    let check = false;
    (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
    return check;
  })();

  export default {
    computed: {
      messageIsEmpty: ({text, images, video}) => (text === '' || text.match(/^\s+$/)) && !images.length && video == null
    },

    data () {
      return {
        _showDropbox: false,
        _imagesLoading: false,
        text: '',
        images: [],
        video: null
      };
    },

    methods: {
      handleKeyDown (event) {
        if (event.keyCode === 13 && !mobile && !event.shiftKey) {
          event.preventDefault();
          this.newMessage();
        }
      },

      handleKeyUp (event) {
        const {text} = this.get();
        const emojied = emoji.emojify(text);
        if (emojied !== text) {
          this.set({text: emojied});
        }
      },

      newMessage () {
        if (this.get().messageIsEmpty) {
          return;
        }

        const {text, images, video} = this.get();
        const {conversation} = this.store.get();

        const message = new Message();
        message.decrypted.text = (text === '' || text.match(/^\s+$/)) ? null : text;
        message.decrypted.images = images;
        message.decrypted.video = video;
        message.set({
          conversation,
          acRead: [...conversation.data.acFull]
        });

        conversation.pending.push(message);

        const saveSuccess = () => {
          conversation.readline = message.cdate;
          conversation.unreadCountPromise = null;

          removePending();
        };

        const removePending = () => {
          const idx = message.arraySearch(conversation.pending);
          if (idx !== false) {
            conversation.pending.splice(idx, 1);
          }

          if (conversation.is(this.store.get().conversation)) {
            this.store.set({conversation});
          } else {
            this.store.set({conversations: this.store.get().conversations});
          }
        };

        message.retrySave = () => message.save(true).then(saveSuccess, ErrHandler);
        message.cancelSave = () => removePending();
        message.save().then(saveSuccess, ErrHandler);

        this.set({text: '', images: [], video: null});
        this.store.set({conversation});
        // Scroll to the bottom when the user adds a pending message.
        this.refs.messageList.fire('scrollToBottom');
        this.focus();
      },

      focus () {
        if (this.refs.textEditor) {
          this.refs.textEditor.focus();
        }
      },

      clearTimeout () {
        if (this.timeout) {
          window.clearTimeout(this.timeout);
          this.timeout = null;
        }
      },

      showTimedDropbox () {
        this.clearTimeout();

        this.set({_showDropbox: true});

        this.timeout = window.setTimeout(() => {
          this.set({_showDropbox: false});
          this.timeout = null;
        }, 2000);
      },

      handleDrag (event, _showDropbox) {
        event.stopPropagation();
        event.preventDefault();

        this.set({_showDropbox});
      },

      handleDrop (event) {
        event.stopPropagation();
        event.preventDefault();

        this.set({_showDropbox: false});
        this.handleFiles(event.dataTransfer.files);
      },

      async handleFiles (files) {
        let imageCount = 0;
        const currentImageCount = this.get().images.length;
        const hasVideo = !!this.get().video;

        if (hasVideo) {
          PNotify.notice({
            title: 'Whoa There',
            text: 'You\'ve already got a video pending. Send it or delete it before you add something else.'
          });
          return;
        }

        for (var i = 0; i < files.length; i++) {
          const file = files[i];

          if (file.type === 'video/webm' || file.type === 'video/mp4') {
            if (currentImageCount + imageCount > 0) {
              PNotify.notice({
                title: 'Images or Video',
                text: 'You gotta pick one.'
              });
              this.set({_imagesLoading: false});
              continue;
            }

            if (file.size >= 20971520) {
              PNotify.notice({
                title: 'Too Big',
                text: 'That video is too big. You can upload videos up to 20MB (MiB).'
              });
              this.set({_imagesLoading: false});
              continue;
            }

            this.set({_imagesLoading: true});

            // Read the video into a temporary video element to check it and
            // generate a thumbnail.
            const video = document.createElement('video');
            const tempObjectURL = URL.createObjectURL(file);
            let resolve;
            const p = new Promise(r => resolve = r);
            video.onloadeddata = () => resolve();
            video.src = tempObjectURL;
            await p;

            // Make sure it's valid.
            if (!video.videoWidth || !video.videoHeight || !video.duration) {
              PNotify.notice({
                title: 'Unreadable',
                text: 'Your browser can\'t read the video stream from this file.'
              });
              this.set({_imagesLoading: false});
              break;
            }

            // Now read the video fully into memory.
            const reader = new FileReader();
            reader.onload = async e => {
              let data = new Uint8Array(e.target.result);

              // This isn't really necessary, but I think it ensures the video
              // element remains intact if the user deletes the source video
              // before sending the message.
              const blob = new Blob([data], {type: file.type});
              const objectURL = URL.createObjectURL(blob);

              let dataType = file.type;
              let resizeImage = new ResizeImage(video, 'image/jpeg');
              const thumbnailImg = await resizeImage.resizeContain(300, 300);
              resizeImage.destroy();
              const thumbnailMatch = thumbnailImg.data.match(/^data:(image\/\w+);base64,(.*)$/);
              const thumbnailType = thumbnailMatch[1];
              const thumbnail = crypt.decodeBase64(thumbnailMatch[2]);

              this.set({
                video: {
                  name: file.name,
                  dataType,
                  dataWidth: '' + video.videoWidth,
                  dataHeight: '' + video.videoHeight,
                  dataDuration: '' + video.duration,
                  data,
                  thumbnailType,
                  thumbnailWidth: '' + thumbnailImg.width,
                  thumbnailHeight: '' + thumbnailImg.height,
                  thumbnail,
                  thumbnailImg: thumbnailImg.data,
                  objectURL
                },
                images: [],
                _imagesLoading: false
              });
            };
            reader.readAsArrayBuffer(file);

            break;
          } else if (!file.type.startsWith('image/')) {
            PNotify.notice({
              title: 'Only Images/Video',
              text: 'Right now, Tunnelgram only supports images, WebM videos, and MP4 videos.'
            });
            this.set({_imagesLoading: false});
          } else if (currentImageCount + imageCount === 9) {
            PNotify.notice({
              title: 'Max Images Reached',
              text: 'You can put up to 9 images into a message.'
            });
            break;
          } else {
            this.set({_imagesLoading: true});
            imageCount++;

            // Read the image into an Image to resize it and generate a
            // thumbnail.
            const image = new Image();
            const tempObjectURL = URL.createObjectURL(file);
            let resolve;
            const p = new Promise(r => resolve = r);
            image.onload = () => resolve();
            image.src = tempObjectURL;
            await p;

            let size = 3000;
            let dataImg;
            let dataMatch;
            let dataType;
            let data;
            let resizeImage = new ResizeImage(image, file.type);
            do {
              // Resize the image repeatedly down until the size is under 2MiB.
              dataImg = await resizeImage.resizeContain(size, size);
              dataMatch = dataImg.data.match(/^data:(image\/\w+);base64,(.*)$/);
              dataType = dataMatch[1];
              data = crypt.decodeBase64(dataMatch[2]);
              size -= 200;
            } while (data.length >= 2097152);
            const thumbnailImg = await resizeImage.resizeContain();
            resizeImage.destroy();
            const thumbnailMatch = thumbnailImg.data.match(/^data:(image\/\w+);base64,(.*)$/);
            const thumbnailType = thumbnailMatch[1];
            const thumbnail = crypt.decodeBase64(thumbnailMatch[2]);

            this.set({
              images: this.get().images.concat([{
                name: file.name,
                dataType,
                dataWidth: '' + dataImg.width,
                dataHeight: '' + dataImg.height,
                data,
                thumbnailType,
                thumbnailWidth: '' + thumbnailImg.width,
                thumbnailHeight: '' + thumbnailImg.height,
                thumbnail,
                thumbnailImg: thumbnailImg.data
              }]),
              video: null
            });

            imageCount--;
            if (imageCount === 0) {
              this.set({_imagesLoading: false});
            }
          }
        }
      }
    },

    components: {
      MessageList,
      LoadingIndicator
    },

    helpers: {
      removeIndex (arr, i) {
        arr.splice(i, 1);
        return arr;
      },

      round (value, precision) {
        return Number.parseFloat(value.toFixed(precision));
      },

      floor: Math.floor
    }
  };
</script>
