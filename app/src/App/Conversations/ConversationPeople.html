<div class="d-flex flex-column align-items-center p-3">
  <div style="width: 600px; max-width: 100%;">
    <ConversationHeader bind:conversation="$conversation" />
  </div>
  <div class="d-flex flex-column justify-content-start" style="width: 600px; max-width: 100%;">
    <h3 class="mt-3">Add People</h3>
    <p>
      {#if $conversation.data.mode === _Conversation.MODE_CONVERSATION}
        People you add will not be able to see any messages that were sent
        before you added them.
      {:elseif $conversation.data.mode === _Conversation.MODE_CHANNEL_PRIVATE}
        People you add will be able to see all previous messages in this
        channel.
      {/if}
    </p>
    <UserSearchSelector ref:userSearchSelector class="d-block" disabled="{_addingUser}" on:userSelected="addUser(event.user)" />
    {#if _addUserError != null}
      <div class="alert alert-danger mt-3 mb-0" role="alert">
        {_addUserError}
      </div>
    {/if}
    <h3 class="mt-3">People in this Conversation</h3>
    <div class="list-group mt-3 text-body">
      {#each $conversation.data.acFull as user, i (user.guid)}
        <a class="list-group-item d-flex justify-content-between align-items-center" href="javascript:void(0)" on:click="$navigate('/u/' + user.data.username)">
          <span><span class="mr-2"><Avatar bind:user="user" /></span> <DisplayName bind:user="user" /> ({user.data.username})</span>
          {#if $user.guid === user.guid}
            <span>(You)</span>
          {/if}
        </a>
      {/each}
    </div>
  </div>
</div>

<script>
  import ConversationHeader from './ConversationHeader.html';
  import UserSearchSelector from '../Users/UserSearchSelector.html';
  import Avatar from '../Users/Avatar.html';
  import DisplayName from '../Users/DisplayName.html';
  import Conversation from '../../Entities/Tunnelgram/Conversation';
  import ErrHandler from '../../ErrHandler';

  export default {
    oncreate () {
      this.storeStateListener = this.store.on('state', ({changed, current}) => {
        if (changed.conversation && current.conversation) {
          // Ready the conversation's referenced entities.
          const {conversation} = current;
          if (conversation.containsSleepingReference && !conversation._tgCalledReadyAll) {
            conversation._tgCalledReadyAll = true;
            conversation.readyAll(null, ErrHandler, 1).then(() => {
              conversation.containsSleepingReference = false;
              conversation._tgCalledReadyAll = false;
              this.store.set({conversation});
            });
          }
        }
      });
    },

    ondestroy() {
      if (this.storeStateListener) {
        this.storeStateListener.cancel();
      }
    },

    data () {
      return {
        _Conversation: Conversation,
        _addingUser: false,
        _addUserError: null
      };
    },

    methods: {
      addUser (user) {
        this.set({
          _addUserError: null,
          _addingUser: false
        });

        if (this.store.get().user.is(user)) {
          this.set({
            _addUserError: 'You\'re already in this conversation.'
          });
          this.refs.userSearchSelector.focus();
          return;
        }

        const {conversation} = this.store.get();

        if (user.inArray(conversation.data.acFull)) {
          this.set({
            _addUserError: 'They\'re already in this conversation.'
          });
          this.refs.userSearchSelector.focus();
          return;
        }

        conversation.data.acFull.push(user);
        this.store.set({conversation});
        this.set({_addingUser: true});
        conversation.save().then(() => {
          this.refs.userSearchSelector.clear();
          this.refs.userSearchSelector.focus();
        }, ErrHandler).finally(() => this.set({
          _addingUser: false
        }));
      }
    },

    components: {
      ConversationHeader,
      UserSearchSelector,
      Avatar,
      DisplayName
    }
  };
</script>
