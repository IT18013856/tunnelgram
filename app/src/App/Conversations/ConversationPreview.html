<div class="d-flex w-100 justify-content-center align-items-center">
  <div class="d-flex justify-content-center align-items-center flex-wrap" style="width: 60px; height: 60px;">
    {#each avatarUsersAndWidth.users as user (user.guid)}
      <Avatar bind:user="user" size={avatarUsersAndWidth.width} />
    {/each}
  </div>
  <div class="pl-2" style="width: calc(100% - 60px);">
    <div class="d-flex w-100 justify-content-between align-items-start">
      <h5 class="mb-0" style="word-break: break-word;">{name}</h5>
      <small class="ml-1" title={_longModifiedDate} style="white-space: nowrap;">{_modifiedDate}</small>
    </div>
    <div class="d-flex w-100 justify-content-between align-items-end">
      {#if conversation.data.lastMessage}
        <small ref:lastmessage>
          {#if conversation.data.lastMessage.decrypted.text != null}
            {conversation.data.lastMessage.decrypted.text}
          {:else if conversation.data.lastMessage.decrypted.images.length === 1}
            [A photo]
          {:else if conversation.data.lastMessage.decrypted.images.length > 1}
            [Photos]
          {:else if conversation.data.lastMessage.decrypted.video !== null}
            [A video]
          {/if}
        </small>
      {:else}
        <span>&nbsp;</span>
      {/if}
      {#if _unreadCount}
        {#await _unreadCount}
          <span>&nbsp;</span>
        {:then count}
          {#if count === 0}
            <span>&nbsp;</span>
          {:else}
            <span class="badge badge-primary">{count === true ? 'New' : count}</span>
          {/if}
        {:catch e}
          <span>&nbsp;</span>
        {/await}
      {/if}
    </div>
  </div>
</div>

<script>
  import Avatar from '../Users/Avatar.html';
  import Conversation from '../../Entities/Tunnelgram/Conversation';
  import {SimpleDateFormatter} from '../../Services/SimpleDateFormatter';
  import ErrHandler from '../../ErrHandler';
  import {settings, user} from '../../stores';

  export default {
    oncreate () {
      const {conversation} = this.get();

      this.interval = window.setInterval(() => this.updateTime(), 10000);
      this.updateTime();
      this.set({
        _unreadCount: conversation.unreadCount()
      });
    },

    onstate ({changed, current, previous}) {
      if (changed.conversation && previous != null) {
        this.updateTime();
        this.set({
          _unreadCount: current.conversation.unreadCount()
        });
      }

      if (changed.conversation && current.conversation) {
        // Ready the conversation's referenced entities.
        const {conversation} = current;
        if (conversation.containsSleepingReference && !conversation._tgCalledReadyAll) {
          conversation._tgCalledReadyAll = true;
          conversation.readyAll(1).then(() => {
            conversation.containsSleepingReference = false;
            conversation._tgCalledReadyAll = false;
            if (!this.destroyed) {
              this.set({conversation});
            }
          }, ErrHandler);
        }
      }
    },

    ondestroy() {
      this.destroyed = true;
      if (this.interval) {
        clearInterval(this.interval);
      }
    },

    computed: {
      name: ({conversation, $settings}) => conversation.getName($settings),
      isOwner: ({conversation, $user}) => $user.is(conversation.data.user),
      avatarUsersAndWidth: ({conversation, $user}) => {
        let users;
        if (!conversation.data.acFull) {
          users = [];
        } else if (conversation.data.acFull.length === 1) {
          users = conversation.data.acFull;
        } else {
          users = conversation.data.acFull.filter(u => !$user.is(u));
        }
        let i = 1;
        while (i**2 < users.length) {
          i++;
        }
        const width = Math.floor(60 / i);
        return {users, width};
      }
    },

    data () {
      return {
        _unreadCount: null,
        conversation: new Conversation()
      }
    },

    methods: {
      updateTime () {
        const {conversation} = this.get();
        this.set({
          _modifiedDate: new SimpleDateFormatter(Math.min(conversation.mdate, (+new Date()) / 100)).format('ago', 'short'),
          _longModifiedDate: new SimpleDateFormatter(conversation.mdate).format('wymdhms', 'short')
        });
      }
    },

    components: {
      Avatar
    }
  };
</script>

<style>
  ref:lastmessage {
    max-width: 100%;
    display: inline-block;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
</style>
