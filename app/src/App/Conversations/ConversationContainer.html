<div class="bg-light text-dark h-100" style="overflow-y: auto; -webkit-overflow-scrolling: touch; overscroll-behavior: contain;">
  {#if $conversation.guid}
    {#if $view === 'conversation'}
      <ConversationView />
    {:elseif $view === 'people'}
      <ConversationPeople />
    {:elseif $view === 'settings'}
      <ConversationSettings />
    {/if}
  {:else}
    <div class="d-flex flex-column align-items-center pt-3">
      <h2>Start a New Conversation</h2>
      <form class="d-flex flex-column justify-content-start w-100 px-2" style="max-width: 600px;" on:submit="save(event.preventDefault())">
        <div class="d-flex">
          <div class="d-inline-block mr-3 flex-grow-1 position-relative userSearchDropdown">
            <input
              type="search"
              class="form-control mr-3 flex-grow-1"
              id="username"
              ref:username
              placeholder="Username or name of contact"
              on:keydown="handleUserSearchKeyDown(event)"
              bind:value="addUsername"
              disabled="{_loadingUser}"
              autocomplete="off" />
            {#if _userSearchPromise}
              {#await _userSearchPromise}
                <div class="dropdown-menu">
                  <span class="dropdown-item-text d-flex justify-content-center">
                    <LoadingIndicator width="18px" height="18px" />
                  </span>
                </div>
              {:then users}
                {#if users.length}
                  <div class="dropdown-menu">
                    {#each users as user}
                      <a class="d-flex justify-content-between align-items-center dropdown-item" href="javascript:void(0)" on:click="addUser(user.data.username)">
                        <span><span class="mr-2"><Avatar user="{user}" /></span> <DisplayName user="{user}" /> ({user.data.username})</span>
                      </a>
                    {/each}
                  </div>
                {/if}
              {/await}
            {/if}
          </div>
          <button type="button" class="btn btn-success" title="Add person" on:click="addUser()" disabled="{_loadingUser}">
            <i class="fas fa-plus"></i>
          </button>
        </div>
        {#if _addUserError != null}
          <div class="alert alert-danger mt-3 mb-0" role="alert">
            {_addUserError}
          </div>
        {/if}
        <button type="submit" class="btn btn-primary mt-3" disabled="{_startingConversation}">{usersOtherThanCurrent.length ? 'Start Talking' : 'Talk Alone'}</button>
        <ul class="list-group mt-3 text-body">
          {#each usersOtherThanCurrent as user (user.guid)}
            <li class="list-group-item d-flex justify-content-between align-items-center">
              <span><span class="mr-2"><Avatar user="{user}" /></span> <DisplayName user="{user}" /></span>
              <button class="btn btn-danger btn-sm" on:click="removeUser(user)">
                <i class="fas fa-minus"></i>
              </button>
            </li>
          {/each}
        </ul>
      </form>
      <h3 class="mt-3">Matching Conversations</h3>
      {#await existingConversations}
        <div>
          One second...
        </div>
      {:then conversations}
        {#if !conversations.length}
          <div>
            Looks like {usersOtherThanCurrent.length ? 'this is a new group' : 'you\'ve got no personal chats'}.
          </div>
        {:else}
          <div class="list-group mt-3 text-body w-100 px-2" style="max-width: 600px;">
            {#each conversations as conversation (conversation.guid)}
              <a class="list-group-item list-group-item-action d-flex justify-content-between align-items-center" href="javascript:void(0)" on:click="$navigate('/c/'+conversation.guid)">
                <h5 class="mb-0">{conversation.getName($settings)}</h5>
                <small class="ml-1" title="{moment.unix(conversation.mdate).format('llll')}" style="white-space: nowrap;">{moment.unix(conversation.mdate).fromNow(true)}</small>
              </a>
            {/each}
          </div>
        {/if}
      {:catch e}
        <div>
          Oops... something went wrong.
        </div>
      {/await}
    </div>
  {/if}
</div>

<script>
  import {Nymph} from 'nymph-client';
  import {User} from 'tilmeld-client';
  import bsn from 'bootstrap.native/dist/bootstrap-native-v4';
  import moment from 'moment';
  import ConversationView from './ConversationView.html';
  import ConversationPeople from './ConversationPeople.html';
  import ConversationSettings from './ConversationSettings.html';
  import Avatar from '../Users/Avatar.html';
  import DisplayName from '../Users/DisplayName.html';
  import LoadingIndicator from '../LoadingIndicator.html';
  import ErrHandler from '../../ErrHandler';

  export default {
    oncreate () {
      if (!this.store.get().conversation.guid) {
        this.refs.username.focus();
      }
    },

    onupdate ({changed, current}) {
      if (changed.addUsername) {
        let users = [];
        let startsWithUsers = [];
        let containUsers = [];
        const {addUsername} = this.get();
        const searchQuery = addUsername.toLowerCase();
        this.set({_userSearchPromise: null});
        if (searchQuery.length >= 2) {
          this.set({_userSearchPromise: new Promise(resolve => {
            // Search for users in the conversations in cache.
            const {conversations, settings, user} = this.store.get();
            conversations.map(conversation => {
              conversation.data.acFull.map(searchUser => {
                if (user.is(searchUser) || searchUser.isASleepingReference) {
                  return;
                }
                let name = searchUser.data.name.toLowerCase();
                if (searchUser.guid in settings.decrypted.nicknames) {
                  name = settings.decrypted.nicknames[searchUser.guid].toLowerCase();
                }
                if (name.startsWith(searchQuery) || searchUser.data.username.startsWith(searchQuery)) {
                  if (!searchUser.inArray(startsWithUsers)) {
                    startsWithUsers.push(searchUser);
                  }
                } else if (name.includes(searchQuery) || searchUser.data.username.includes(searchQuery)) {
                  if (!searchUser.inArray(containUsers)) {
                    containUsers.push(searchUser);
                  }
                }
              });
            });
            users = [...users, ...startsWithUsers, ...containUsers];
            startsWithUsers = [];
            containUsers = [];
            resolve(users);
          })});
          // TODO(hperrin): Search for nicknames.
          // TODO(hperrin): Search for users in conversations from the server.
        }
      }
    },

    computed: {
      usersOtherThanCurrent: ({$conversation, $user}) => $conversation.data.acFull && $conversation.data.acFull.filter(user => !$user.is(user)),
      existingConversations: ({$conversation}) => {
        if ($conversation.guid) {
          return null;
        }

        return $conversation.findMatchingConversations().then(async conversations => {
          await Promise.all(conversations.map(conversation => conversation.readyAll(undefined, ErrHandler, 1)));
          return conversations;
        })
      }
    },

    data () {
      return {
        _startingConversation: false,
        _loadingUser: false,
        _addUserError: null,
        addUsername: ''
      };
    },

    methods: {
      handleUserSearchKeyDown (event) {
        if (event.keyCode === 13) {
          this.addUser();
          event.preventDefault();
        }
      },

      async addUser (addUsername) {
        this.set({
          _loadingUser: true,
          _addUserError: null
        });

        if (!addUsername) {
          addUsername = this.get().addUsername.replace(/\\\\/g, '\\\\\\\\').replace(/%/g, '\\%').replace(/_/g, '\\_');
        }

        if (!addUsername || addUsername.match(/^\s+$/)) {
          this.set({
            _loadingUser: false,
            _addUserError: 'Looks like you didn\'t give a username.'
          });
          this.refs.username.focus();
          return;
        }

        try {
          const user = await Nymph.getEntity({
            'class': User.class
          }, {
            'type': '&',
            'ilike': ['username', addUsername]
          });

          if (!user) {
            this.set({
              _loadingUser: false,
              _addUserError: 'Hmm. That user couldn\'t be found.'
            });
            this.refs.username.focus();
            return;
          }

          if (this.store.get().user.is(user)) {
            this.set({
              _loadingUser: false,
              _addUserError: 'You\'re already in any conversation that you start.'
            });
            this.refs.username.focus();
            return;
          }

          const {conversation} = this.store.get();

          if (user.inArray(conversation.data.acFull)) {
            this.set({
              _loadingUser: false,
              _addUserError: 'Looks like you\'ve already added that user.'
            });
            this.refs.username.focus();
            return;
          }

          conversation.data.acFull.push(user);
          this.store.set({conversation});
          this.set({
            _loadingUser: false,
            addUsername: ''
          });
          this.refs.username.focus();
        } catch (e) {
          this.set({
            _loadingUser: false,
            _addUserError: e.textStatus
          });
          this.refs.username.focus();
        }
      },

      removeUser (userToRemove) {
        const {conversation} = this.store.get();
        conversation.set({acFull: conversation.data.acFull.filter(user => !userToRemove.is(user))});
        this.store.set({conversation});
      },

      save () {
        const {conversation} = this.store.get();
        this.set({_startingConversation: true});
        conversation.save().then(() => this.store.navigate('/c/'+conversation.guid), ErrHandler).finally(() => {
          this.set({_startingConversation: false});
        });
      }
    },

    components: {
      ConversationView,
      ConversationPeople,
      ConversationSettings,
      Avatar,
      DisplayName,
      LoadingIndicator
    },

    helpers: {
      moment
    }
  };
</script>

<style>
  .userSearchDropdown:focus-within .dropdown-menu {
    display: block;
  }
</style>
