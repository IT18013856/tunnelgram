<div class="d-flex flex-column align-items-center pt-3">
  <h2>Start a Conversation</h2>
  <form class="d-flex flex-column justify-content-start px-2" style="width: 600px; max-width: 100vw;" on:submit="save(event.preventDefault())">
    <h3 class="mt-3">Add People</h3>
    <div class="d-flex">
      <div class="d-inline-block mr-3 flex-grow-1 position-relative" ref:userSearchDropdown>
        <input
          type="search"
          class="form-control mr-3 flex-grow-1"
          id="username"
          ref:username
          placeholder="Username or name"
          on:keydown="handleUserSearchKeyDown(event)"
          bind:value="addUsername"
          disabled="{_loadingUser}"
          autocomplete="off"
          on:focus="set({_showUserSearchDropdown: true})" />
        {#if searchUsers.length || _userSearchPromiseServer}
          <div class="dropdown-menu mt-0 {_showUserSearchDropdown ? 'show' : ''}">
            {#each searchUsers as user}
              <a class="d-flex justify-content-between align-items-center dropdown-item" href="javascript:void(0)" on:click="addUser(user)">
                <span><span class="mr-2"><Avatar bind:user="user" /></span> <DisplayName bind:user="user" /> ({user.data.username})</span>
              </a>
            {/each}
            {#await _userSearchPromiseServer}
              <span class="dropdown-item-text d-flex justify-content-center">
                <LoadingIndicator width="18" height="18" />
              </span>
            {:then serverUsers}
              {#if searchUsers.length && serverUsers.length}
                <span class="dropdown-item-text d-flex justify-content-center my-2">
                  Others
                </span>
              {/if}
              {#each serverUsers as user}
                <a class="d-flex justify-content-between align-items-center dropdown-item" href="javascript:void(0)" on:click="addUser(user)">
                  <span><span class="mr-2"><Avatar bind:user="user" /></span> <DisplayName bind:user="user" /> ({user.data.username})</span>
                </a>
              {/each}
            {/await}
          </div>
        {/if}
      </div>
      <button type="button" class="btn btn-success" title="Add person" on:click="addUsername()" disabled="{_loadingUser}">
        <i class="fas fa-plus"></i>
      </button>
    </div>
    {#if _addUserError != null}
      <div class="alert alert-danger mt-3 mb-0" role="alert">
        {_addUserError}
      </div>
    {/if}
    <ul class="list-group mt-3 text-body">
      {#each usersOtherThanCurrent as user (user.guid)}
        <li class="list-group-item d-flex justify-content-between align-items-center">
          <span><span class="mr-2"><Avatar bind:user="user" /></span> <DisplayName bind:user="user" /></span>
          <button class="btn btn-danger btn-sm" on:click="removeUser(user)">
            <i class="fas fa-minus"></i>
          </button>
        </li>
      {/each}
    </ul>
    <h3 class="mt-3">Matching Conversations</h3>
    <div>
      {#await existingConversations}
        <div>
          One second...
        </div>
      {:then conversations}
        {#if !conversations.length}
          <div>
            Looks like {usersOtherThanCurrent.length ? 'this is a new group' : 'you\'ve got no personal chats'}.
          </div>
          <button type="submit" class="btn btn-primary my-3 w-100" disabled="{_startingConversation}">{usersOtherThanCurrent.length ? 'Start Talking' : 'Talk Alone'}</button>
        {:else}
          <div class="list-group mt-3 text-body">
            {#each conversations as conversation (conversation.guid)}
              <a class="list-group-item list-group-item-action" href="javascript:void(0)" on:click="$navigate('/c/'+conversation.guid)">
                <ConversationPreview bind:conversation="conversation" />
              </a>
            {/each}
          </div>
          <h3 class="mt-3">Or Start a New One</h3>
          <button type="submit" class="btn btn-light my-3 w-100" disabled="{_startingConversation}">{usersOtherThanCurrent.length ? 'Start Talking' : 'Talk Alone'}</button>
        {/if}
      {:catch e}
        <div>
          Oops... something went wrong.
        </div>
        <h3 class="mt-3">Start a New One</h3>
        <button type="submit" class="btn btn-light my-3 w-100" disabled="{_startingConversation}">{usersOtherThanCurrent.length ? 'Start Talking' : 'Talk Alone'}</button>
      {/await}
    </div>
  </form>
</div>


<script>
  import {Nymph} from 'nymph-client';
  import {User} from 'tilmeld-client';
  import ConversationPreview from './ConversationPreview.html';
  import Avatar from '../Users/Avatar.html';
  import DisplayName from '../Users/DisplayName.html';
  import LoadingIndicator from '../LoadingIndicator.html';
  import ErrHandler from '../../ErrHandler';

  export default {
    onupdate ({changed, current}) {
      if (changed.addUsername) {
        const {addUsername} = this.get();
        const searchQuery = addUsername.toLowerCase();
        this.set({
          searchUsers: [],
          _userSearchPromiseServer: null,
        });
        if (searchQuery.length >= 2) {
          let searchUsers = [];
          // Search for users in the conversations in cache.
          let startsWithUsers = [];
          let containUsers = [];
          const {conversations, settings, user} = this.store.get();
          conversations.map(conversation => {
            conversation.data.acFull.map(searchUser => {
              if (user.is(searchUser) || searchUser.isASleepingReference) {
                return;
              }
              let name = searchUser.data.name.toLowerCase();
              if (searchUser.guid in settings.decrypted.nicknames) {
                name = settings.decrypted.nicknames[searchUser.guid].toLowerCase();
              }
              if (name.startsWith(searchQuery) || searchUser.data.username.startsWith(searchQuery)) {
                if (!searchUser.inArray(startsWithUsers)) {
                  startsWithUsers.push(searchUser);
                }
              } else if (name.includes(searchQuery) || searchUser.data.username.includes(searchQuery)) {
                if (!searchUser.inArray(containUsers)) {
                  containUsers.push(searchUser);
                }
              }
            });
          });
          searchUsers = [...startsWithUsers, ...containUsers];
          this.set({
            searchUsers,
            _userSearchPromiseServer: new Promise(resolve => {
              window.clearTimeout(this.get()._userSearchTimer);
              this.set({
                _userSearchTimer: window.setTimeout(async () => {
                  const guids = [];
                  for (let guid in settings.decrypted.nicknames) {
                    if (settings.decrypted.nicknames[guid].toLowerCase().includes(searchQuery)) {
                      guids.push(guid);
                    }
                  }
                  const nickPromise = guids.length ? Nymph.getEntities({
                    'class': User.class
                  }, {
                    'type': '|',
                    'guid': guids
                  }) : Promise.resolve([]);

                  const firstArgs = [{
                    'class': User.class,
                    'limit': 10
                  }, {
                    'type': '&',
                    '!guid': [
                      ...Object.keys(settings.decrypted.nicknames),
                      user.guid,
                      ...searchUsers.map(user => user.guid)
                    ]
                  }];
                  const unPromise = Nymph.getEntities(...firstArgs, {
                    'type': '&',
                    'ilike': ['username', searchQuery+'%']
                  });
                  const namePromise = Nymph.getEntities(...firstArgs, {
                    'type': '&',
                    'ilike': ['name', '%'+searchQuery+'%']
                  });

                  const nickUsers = await nickPromise;
                  const unUsers = await unPromise;
                  const nameUsers = await namePromise;

                  for (let i in nickUsers) {
                    if (nickUsers[i].inArray(searchUsers)) {
                      nickUsers.splice(i, 1);
                    }
                  }
                  for (let i in nameUsers) {
                    if (nameUsers[i].inArray(unUsers)) {
                      nameUsers.splice(i, 1);
                    }
                  }

                  resolve([...nickUsers, ...unUsers, ...nameUsers]);
                }, 150)
              });
            })
          });
        }
      }
    },

    computed: {
      usersOtherThanCurrent: ({$conversation, $user}) => $conversation.data.acFull && $conversation.data.acFull.filter(user => !$user.is(user)),
      existingConversations: ({$conversation}) => {
        if ($conversation.guid) {
          return null;
        }

        return $conversation.findMatchingConversations().then(async conversations => {
          await Promise.all(conversations.map(conversation => conversation.readyAll(null, ErrHandler, 1)));
          return conversations;
        })
      }
    },

    data () {
      return {
        _showUserSearchDropdown: false,
        _userSearchTimer: null,
        _startingConversation: false,
        _loadingUser: false,
        _addUserError: null,
        searchUsers: [],
        addUsername: ''
      };
    },

    methods: {
      handleUserSearchKeyDown (event) {
        if (event.keyCode === 13) {
          this.addUsername();
          event.preventDefault();
        }
      },

      checkToHideUserSearchDropdown (event) {
        let hide = false;
        let target = event.target;
        while (target.parentNode) {
          if (target === this.refs.userSearchDropdown) {
            break;
          }
          if (target === document.body) {
            hide = true;
            break;
          }
          target = target.parentNode;
        }
        if (hide) {
          this.set({_showUserSearchDropdown: false});
        }
      },

      async addUsername (addUsername) {
        this.set({
          _loadingUser: true,
          _addUserError: null,
          _showUserSearchDropdown: false
        });

        if (!addUsername) {
          addUsername = this.get().addUsername.replace(/\\\\/g, '\\\\\\\\').replace(/%/g, '\\%').replace(/_/g, '\\_');
        }

        if (!addUsername || addUsername.match(/^\s+$/)) {
          this.set({
            _loadingUser: false,
            _addUserError: 'Looks like you didn\'t give a username.'
          });
          this.focusUsername();
          return;
        }

        try {
          const user = await Nymph.getEntity({
            'class': User.class
          }, {
            'type': '&',
            'ilike': ['username', addUsername]
          });

          if (!user) {
            this.set({
              _loadingUser: false,
              _addUserError: 'Hmm. That user couldn\'t be found.'
            });
            this.focusUsername();
            return;
          }

          this.set({_loadingUser: false});
          this.addUser(user);
        } catch (e) {
          this.set({
            _loadingUser: false,
            _addUserError: e.textStatus
          });
          this.focusUsername();
        }
      },

      addUser (user) {
        this.set({
          _addUserError: null
        });

        if (this.store.get().user.is(user)) {
          this.set({
            _addUserError: 'You\'re already in any conversation that you start.'
          });
          this.focusUsername();
          return;
        }

        const {conversation} = this.store.get();

        if (user.inArray(conversation.data.acFull)) {
          this.set({
            _addUserError: 'Looks like you\'ve already added that user.'
          });
          this.focusUsername();
          return;
        }

        conversation.data.acFull.push(user);
        this.store.set({conversation});
        this.set({
          addUsername: ''
        });
        this.focusUsername();
      },

      focusUsername () {
        this.refs.username.focus();
        this.set({_showUserSearchDropdown: true});
      },

      removeUser (userToRemove) {
        const {conversation} = this.store.get();
        conversation.set({acFull: conversation.data.acFull.filter(user => !userToRemove.is(user))});
        this.store.set({conversation});
      },

      save () {
        const {conversation} = this.store.get();
        this.set({_startingConversation: true});
        conversation.save().then(() => this.store.navigate('/c/'+conversation.guid), ErrHandler).finally(() => {
          this.set({_startingConversation: false});
        });
      }
    },

    components: {
      ConversationPreview,
      Avatar,
      DisplayName,
      LoadingIndicator
    }
  };
</script>
