<div class="h-100" style="overflow-y: auto; -webkit-overflow-scrolling: touch; overscroll-behavior: contain;" bind:this={container} on:scroll={handleScroll}>
  <div class="list-group">
    <div class="list-group-item list-group-item-action rounded-0 {$conversation.guid == null ? 'active' : ''}" style="cursor: pointer;" tabindex="0" on:click={() => navigate('/c')}>
      <h5 class="mb-0 d-flex w-100 align-items-center"><i class="fas fa-plus-circle mr-1"></i> New Conversation</h5>
    </div>
    {#if $conversations.length > 1}
      <div class="list-group-item d-flex p-0 border-0">
        <input type="text" class="form-control bg-secondary border-0 text-light" bind:value={_search} name="search" placeholder="Search people" autocomplete="off" />
      </div>
    {/if}
    {#if !_loading}
      {#each $conversations as curConversation (curConversation.guid)}
        <div class="list-group-item p-2 list-group-item-action rounded-0 flex-column align-items-start {curConversation.guid === $conversation.guid ? 'active' : ''} {curConversation.inArray(filteredConversations) ? '' : 'd-none'}" style="cursor: pointer;" tabindex="0" on:click={() => navigateConversation(curConversation)}>
          <ConversationPreview bind:conversation={curConversation} />
        </div>
      {/each}
      {#if !$conversations.length}
        <div class="list-group-item p-2 rounded-0 flex-column align-items-start bg-transparent border-0">
          {#if $conversations.length}
            No matching conversations.
          {:else}
            You have no conversations yet.
          {/if}
        </div>
      {/if}
    {/if}
    {#if _loading || !_reachedEarliestConversation}
      <div class="list-group-item p-2 rounded-0 d-flex align-items-center justify-content-center align-self-stretch bg-transparent border-0 {_loadingEarlierConversations ? '' : 'visibility-hidden'}">
        <div class="col-auto">
          <LoadingIndicator width="50" height="50" />
        </div>
      </div>
    {/if}
  </div>
</div>

<script>
  import {onMount, onDestroy, createEventDispatcher} from 'svelte';
  import {Nymph, PubSub} from 'nymph-client';
  import Conversation from '../../Entities/Tunnelgram/Conversation';
  import LoadingIndicator from '../LoadingIndicator';
  import ConversationPreview from './ConversationPreview';
  import {navigate} from '../../Services/router';
  import ErrHandler from '../../ErrHandler';
  import {conversation, conversations, user, settings} from '../../stores';

  const CONVERSATION_PAGE_SIZE = 8;

  const dispatch = createEventDispatcher();

  let _disconnected = false;
  let _loading = true;
  let _loadingEarlierConversations = false;
  let _reachedEarliestConversation = false;
  let _search = '';
  let destroyed = false;
  let subscription;
  let container;
  const onPubSubConnect = () => {
    if (_disconnected) {
      Nymph.getEntities({
        'class': Conversation.class,
        'sort': 'mdate',
        'reverse': true
      }, {
        'type': '&',
        'ref': ['acFull', $user.guid],
        'gt': ['mdate', $conversations.length ? Math.max(...$conversations.map(c => c.mdate)) : 0]
      }).then(newConversations => {
        $conversations = [...newConversations, ...$conversations.filter(c => !c.inArray(newConversations))];
      });
    }
    _disconnected = false;
  };
  const onPubSubDisconnect = () => {
    _disconnected = true;
  };

  $: filteredConversations = (() => {
    if (_search === '' || !$settings) {
      return $conversations;
    }
    const searchLC = _search.toLowerCase();
    const nicknameUserGUIDs = Object.entries($settings.decrypted.nicknames).filter(entry => {
      const [guid, nickname] = entry;
      return nickname.toLowerCase().indexOf(searchLC) !== -1;
    }).map(entry => parseFloat(entry[0]));
    return $conversations.filter(c => {
      for (let user of c.data.acFull) {
        if (user.isASleepingReference || ($user.is(user) && c.data.acFull.length > 1)) {
          continue;
        } else if (nicknameUserGUIDs.indexOf(user.guid) !== -1) {
          return true;
        } else if (!(user.guid in $settings.decrypted.nicknames) && user.data.name.toLowerCase().indexOf(searchLC) !== -1) {
          return true;
        }
      }
      return false;
    });
  })();

  let previousUser = $user;
  $: if ($user && !$user.is(previousUser)) {
    subscribe();
    previousUser = $user;
  }

  let previousConversationsLength = $conversations.length;
  $: if (previousConversationsLength !== $conversations.length) {
    handleScroll();
    previousConversationsLength = $conversations.length;
  }

  $: if (_search !== null) {
    handleScroll();
  }

  onMount(() => {
    subscribe();

    PubSub.on('connect', onPubSubConnect);
    PubSub.on('disconnect', onPubSubDisconnect);
  });

  onDestroy(() => {
    destroyed = true;
    if (subscription) {
      subscription.unsubscribe();
    }

    PubSub.off('connect', onPubSubConnect);
    PubSub.off('disconnect', onPubSubDisconnect);
  });

  function subscribe () {
    if (subscription) {
      subscription.unsubscribe();
    }

    _loading = true;

    subscription = Nymph.getEntities({
      'class': Conversation.class,
      'sort': 'mdate',
      'reverse': true,
      'limit': CONVERSATION_PAGE_SIZE
    }, {
      'type': '&',
      'ref': ['acFull', $user.guid]
    }).subscribe(update => {
      if (destroyed) {
        return;
      }
      _loading = false;
      if (update) {
        if (Array.isArray(update)) {
          if (update.length < CONVERSATION_PAGE_SIZE) {
            _reachedEarliestConversation = true;
          }
        } else {
          dispatch('tunnelgram-notification', update);
        }
        PubSub.updateArray($conversations, update);
        $conversations = $conversations;
        handleScroll();
      }
    }, ErrHandler);
  }

  function navigateConversation (conversation) {
    dispatch('tunnelgram-navigate', conversation);
    _search = '';
  }

  function handleScroll () {
    if (container && container.scrollTop > (container.scrollHeight - container.clientHeight - 150)) {
      loadEarlierConversations();
    }
  }

  async function loadEarlierConversations () {
    if (_loadingEarlierConversations || _reachedEarliestConversation) {
      return;
    }

    if (!$conversations.length) {
      return;
    }

    _loadingEarlierConversations = true;

    try {
      const earlierConversations = await Nymph.getEntities({
        'class': Conversation.class,
        'sort': 'mdate',
        'reverse': true,
        'limit': CONVERSATION_PAGE_SIZE
      }, {
        'type': '&',
        'ref': ['acFull', $user.guid],
        'lt': ['mdate', Math.min(...$conversations.map(c => c.mdate))]
      });

      if (earlierConversations && earlierConversations.length) {
        $conversations = [...$conversations, ...earlierConversations];
        if (earlierConversations.length < CONVERSATION_PAGE_SIZE) {
          _reachedEarliestConversation = true;
        }
      } else {
        _reachedEarliestConversation = true;
      }
    } catch (e) {
      ErrHandler(e);
    }

    _loadingEarlierConversations = false;
  }
</script>
