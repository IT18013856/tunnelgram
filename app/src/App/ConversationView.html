<div class="d-flex flex-column h-100">
  <div class="flex-grow-1  position-relative">
    <MessageList />
  </div>
  <form class="d-flex align-items-stretch" on:submit="newMessage(event.preventDefault())">
    <div class="flex-grow-1" ref:textContainer>
      <textarea class="w-100 border-primary border-top" ref:text></textarea>
    </div>
    <button class="btn btn-lg btn-primary" style="width: 80px;" disabled="{textLoading || textIsEmpty}"><i class="fas fa-comment"></i></button>
  </form>
</div>

<script>
  import Message from '../Entities/Message';
  import MessageList from './MessageList.html';
  import EmojiConvertor from 'emoji-js';
  import ErrHandler from '../ErrHandler';
  import SimpleMDE from 'simplemde';

  const emoji = new EmojiConvertor();

  export default {
    oncreate () {
      this.editor = new SimpleMDE({
        element: this.refs.text,
        autoDownloadFontAwesome: false,
        autofocus: true,
        placeholder: 'New message',
        spellChecker: false,
        status: false,
        toolbar: false
      });
      this.editor.codemirror.on('keydown', (codemirror, event) => {
        this.handleKeyDown(event);
        if (this.get().textLoading) {
          event.preventDefault();
        }
      });
      this.editor.codemirror.on('keyup', (codemirror, event) => {
        this.handleKeyUp(event);
      });
      this.editor.codemirror.on('change', () => {
        const text = this.editor.value();
        if (this.get().text !== text) {
          this.set({text});
        }
      });
      this.editor.value(this.get().text);
      this.editor.codemirror.setOption('readOnly', this.get().textLoading);
    },

    onstate ({changed, current}) {
      if (changed.text && this.editor) {
        const text = this.editor.value();
        if (text !== current.text) {
          this.editor.value(current.text);
          this.editor.codemirror.execCommand('goDocEnd');
        }
        this.editor.codemirror.setOption('readOnly', current.textLoading);
      }
    },

    ondestroy () {
      this.editor.toTextArea();
    },

    computed: {
      textIsEmpty: ({text}) => text === '' || text.match(/^\s+$/)
    },

    data () {
      return {
        textLoading: false,
        text: ''
      };
    },

    methods: {
      handleKeyDown (event) {
        if (event.keyCode === 13 && !event.shiftKey) {
          event.preventDefault();
          this.newMessage();
        }
      },

      handleKeyUp (event) {
        const {text} = this.get();
        const emojied = emoji.replace_colons(text);
        if (emojied !== text) {
          this.set({text: emojied});
        }
      },

      newMessage () {
        if (this.get().textIsEmpty) {
          return;
        }

        this.set({textLoading: true});

        const {text} = this.get();
        const {conversation} = this.store.get();

        const message = new Message();
        message.decrypted.text = text;
        message.set({
          conversation,
          acRead: [...conversation.data.acFull]
        });

        message.save().then(() => {
          this.set({textLoading: false, text: ''});
            this.refs.text.focus();
        }, (...args) => {
          this.set({textLoading: false});
          this.refs.text.focus();
          ErrHandler(...args);
        });
      }
    },

    components: {
      MessageList
    }
  };
</script>

<style>
  ref:textContainer :global(.CodeMirror) {
    min-height: 100px;
    height: 100px;
  }
</style>
