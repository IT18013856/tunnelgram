<svelte:window on:resize="handleWindowResize()" />
<div class="position-absolute h-100 w-100 pt-3" style="overflow-y: auto; overflow-x: hidden;" ref:container on:scroll="handleScroll()">
  {#if _loading}
    <div class="d-flex align-items-center justify-content-center" style="height: 200px;">
      <div class="col-auto">
        <LoadingIndicator width="50px" height="50px" />
      </div>
    </div>
  {:else}
    <div class="d-flex flex-column align-items-start" ref:messageContainer>
      <div class="align-self-stretch text-center">
        <h1>{name}</h1>
        <p>
          Started {moment.unix($conversation.cdate).format('llll')}
        </p>
      </div>
      {#if _loadingEarlierMessages}
        <div class="d-flex align-items-center justify-content-center align-self-stretch" style="height: 200px;">
          <div class="col-auto">
            <LoadingIndicator width="50px" height="50px" />
          </div>
        </div>
      {/if}
      {#each messages as message, i (message.guid)}
        <MessageView bind:message on:rendered="rescrollToBottom()" on:deleted="removeMessage(message)" readLineCDate="{_showReadline && _initialReadline}" showAvatar="{messages.length === i + 1 || messages[i + 1].data.user.guid !== message.data.user.guid}" showTime="{i > 0 && showTime(messages[i - 1].cdate, message.cdate)}"></MessageView>
      {/each}
      {#each $conversation.pending as message}
        <MessageView bind:message on:rendered="rescrollToBottom()" pending="true" showTime="{messages.length && showTime(messages[messages.length - 1].cdate)}"></MessageView>
      {/each}
    </div>
  {/if}
</div>

<script>
  import {Nymph, PubSub} from 'nymph-client';
  import moment from 'moment';
  import Message from '../../Entities/Message';
  import LoadingIndicator from '../LoadingIndicator.html';
  import MessageView from './MessageView.html';
  import ErrHandler from '../../ErrHandler';

  const MESSAGE_PAGE_SIZE = 20;

  export default {
    oncreate () {
      this.destroyed = false;
      this.subscribe();
      const {conversation} = this.store.get();
      this.set({
        _initialReadline: conversation.readline,
        _latestReadline: conversation.readline
      });
      this.scrollWaitBottom = true;
      this.scrollWaitReadline = false;

      this.scrollToBottomListener = this.on('scrollToBottom', () => {
        if (!this.scrollWaitReadline) {
          this.scrollWaitBottom = true;
          this.scrollToBottom();
        }
      });

      this.onPubSubConnect = () => {
        if (this.get()._disconnected) {
          const {messages} = this.get();
          const {conversation} = this.store.get();
          Nymph.getEntities({
            'class': Message.class,
            'sort': 'cdate'
          }, {
            'type': '&',
            'ref': ['conversation', conversation.guid],
            'gt': ['cdate', messages.length ? messages[messages.length - 1].cdate : 0]
          }).then(newMessages => {
            this.set({messages: [...messages, ...newMessages]})
          });
        }
        this.set({_disconnected: false});
      };

      this.onPubSubDisconnect = () => {
        this.set({_disconnected: true});
      };

      PubSub.on('connect', this.onPubSubConnect);
      PubSub.on('disconnect', this.onPubSubDisconnect);
    },

    onstate ({changed, current}) {
      const {_showReadline, _initialReadline, messages} = current;
      if (_showReadline === null && _initialReadline !== 0 && messages.length) {
        const visibleReadLine = _initialReadline > 0
          && _initialReadline < messages[messages.length - 1].cdate;
        this.set({
          _showReadline: visibleReadLine
        });
        if (visibleReadLine) {
          this.scrollWaitReadline = window.setTimeout(() => {
            this.scrollWaitReadline = false;
            this.scrollToReadLine();
          }, 500);
          this.scrollWaitBottom = false;
        }
      }
    },

    onupdate ({changed, current}) {
      if ((
          // Scroll to the bottom when the messages are first loaded.
          (changed._loading && !current._loading && !this.scrollWaitReadline) ||
          // Scroll to the bottom when new messages come in, if the user is at the bottom and the window is focused.
          (changed.messages && current._isAtBottom && ('hasFocus' in document ? document.hasFocus() : !document.hidden) && !this.scrollWaitReadline)
        )) {
        this.scrollWaitBottom = true;
        this.scrollToBottom();
      }

      if (changed._loadingEarlierMessages && !(current._isAtBottom && !changed._loadingEarlierMessages)) {
        // Scroll to offset the added/removed height of the loading indicator.
        this.refs.container.scrollTop += 200 * (current._loadingEarlierMessages ? 1 : -1);
      }

      if (changed._scrollToDistanceFromBottom && current._scrollToDistanceFromBottom != null) {
        window.requestAnimationFrame(() => {
          this.refs.container.scrollTop = this.refs.container.scrollHeight - current._scrollToDistanceFromBottom;
        });
      }

      // Perform any scrolls that have been waiting.
      if (this.scrollWaitReadline) {
        window.clearTimeout(this.scrollWaitReadline);
        this.scrollWaitReadline = false;
        this.scrollToReadLine();
      }
    },

    ondestroy () {
      this.destroyed = true;
      let {_subscription} = this.get();
      if (_subscription) {
        _subscription.unsubscribe();
      }

      this.scrollToBottomListener.cancel();

      PubSub.off('connect', this.onPubSubConnect);
      PubSub.off('disconnect', this.onPubSubDisconnect);
    },

    computed: {
      name: ({$conversation, $conversations, $settings}) => $conversation.getName($settings)
    },

    data () {
      return {
        _disconnected: false,
        _isAtBottom: true,
        _showReadline: null,
        _initialReadline: null,
        _latestReadline: null,
        _loadingEarlierMessages: false,
        _reachedEarliestMessage: false,
        _scrollToDistanceFromBottom: null,
        messages: []
      };
    },

    methods: {
      subscribe () {
        let {_subscription} = this.get();
        if (_subscription) {
          _subscription.unsubscribe();
        }

        this.set({_loading: true});

        const {conversation} = this.store.get();
        _subscription = Nymph.getEntities({
          'class': Message.class,
          'sort': 'cdate',
          'reverse': true,
          'limit': MESSAGE_PAGE_SIZE
        }, {
          'type': '&',
          'ref': ['conversation', conversation.guid]
        }).subscribe(update => {
          if (this.destroyed) {
            return;
          }
          if (update) {
            const {messages} = this.get();
            if (Array.isArray(update)) {
              if (update.length < MESSAGE_PAGE_SIZE) {
                this.set({_reachedEarliestMessage: true});
              }
            }
            PubSub.updateArray(messages, update);
            Nymph.sort(messages, 'cdate');
            // Setting _loading needs to go before handleScroll to scroll to the bottom on initial load.
            this.set({messages, _loading: false});
            this.createNewReadlineIfNeeded();
            this.handleScroll();

            if (update.added) {
              // Remove the message from pending messages.
              const {user, conversation} = this.store.get();
              const ent = update.data;
              for (let i = 0; i < conversation.pending.length; i++) {
                const cur = conversation.pending[i];
                if (ent.data.keys[user.guid] === cur.data.keys[user.guid]) {
                  conversation.pending.splice(i, 1);
                  this.store.set({conversation});
                  break;
                }
              }
            }
          } else {
            this.set({_loading: false});
          }
        }, (err) => {
          ErrHandler(err);
          this.set({_loading: false});
        });
        this.set({_subscription});
      },

      handleScroll () {
        if (this.refs.container.scrollTop < 100) {
          this.loadEarlierMessages();
        }

        this.setIsAtBottom();
        this.updateReadline();
      },

      handleWindowResize () {
        // Scroll to the bottom if the user was at the bottom.
        if (this.get()._isAtBottom) {
          this.scrollToBottom();
        }
      },

      setIsAtBottom () {
        this.set({_isAtBottom: this.refs.container.scrollTop >= (this.refs.container.scrollHeight - this.refs.container.offsetHeight)});
      },

      async loadEarlierMessages () {
        const {_loadingEarlierMessages, _reachedEarliestMessage} = this.get();
        if (_loadingEarlierMessages || _reachedEarliestMessage || this.scrollWaitReadline || this.scrollWaitBottom) {
          return;
        }

        const {messages} = this.get();
        const {conversation} = this.store.get();

        if (!messages.length) {
          return;
        }

        this.set({_loadingEarlierMessages: true});

        try {
          const earlierMessages = await Nymph.getEntities({
            'class': Message.class,
            'sort': 'cdate',
            'reverse': true,
            'limit': MESSAGE_PAGE_SIZE
          }, {
            'type': '&',
            'ref': ['conversation', conversation.guid],
            'lt': ['cdate', messages[0].cdate]
          });

          if (earlierMessages && earlierMessages.length) {
            const distanceFromBottom = this.refs.container.scrollHeight - this.refs.container.scrollTop;
            Nymph.sort(earlierMessages, 'cdate');
            this.set({messages: [...earlierMessages, ...messages], _scrollToDistanceFromBottom: distanceFromBottom});
          } else {
            this.set({_reachedEarliestMessage: true});
          }
        } catch (e) {
          ErrHandler(e);
        }

        this.set({_loadingEarlierMessages: false});
      },

      updateReadline () {
        // Don't update the readline if the user doesn't have the page open.
        if ('hasFocus' in document ? !document.hasFocus() : document.hidden) {
          return;
        }
        // Update readline on next animation frame (so that the DOM can be updated).
        window.requestAnimationFrame(async () => {
          if (!this.refs.messageContainer) {
            return;
          }
          const {_latestReadline} = this.get();
          if (_latestReadline !== null) {
            const messageEls = this.refs.messageContainer.querySelectorAll('.message[data-cdate]');
            const messageElsInViewport = Array.from(messageEls).filter((el) => {
                const containerTop = this.refs.container.scrollTop;
                const containerBottom = containerTop + this.refs.container.clientHeight;
                const elBottom = el.offsetTop + el.offsetHeight;
                return (elBottom >= containerTop)
                       && (elBottom <= containerBottom);
            });
            if (messageElsInViewport.length) {
              const latestReadMessageEl = messageElsInViewport[messageElsInViewport.length - 1];
              const updateReadline = JSON.parse(latestReadMessageEl.dataset.cdate);
              if (updateReadline > _latestReadline) {
                this.set({_latestReadline: updateReadline});
                const {conversation} = this.store.get();
                await conversation.saveReadline(updateReadline);
                this.store.set({conversation});
              }
            }
          }
        });
      },

      async createNewReadlineIfNeeded () {
        const {conversation} = this.store.get();
        const {messages} = this.get();
        if (conversation.readline == null && messages.length) {
          const updateReadline = messages[messages.length - 1].cdate;
          this.set({
            _initialReadline: updateReadline,
            _latestReadline: updateReadline
          });
          await conversation.saveReadline(updateReadline);
          this.store.set({conversation});
        }
      },

      scrollToReadLine () {
        const readlineEl = this.refs.container.querySelector('.readline');
        if (readlineEl) {
          this.refs.container.scrollTop = Math.max(0, readlineEl.offsetTop - (this.refs.container.clientHeight * .5));
          this.setIsAtBottom();
          this.updateReadline();
        }
      },

      scrollToBottom () {
        this.refs.container.scrollTop = this.refs.container.scrollHeight;
        this.scrollWaitBottom = false;
        this.set({_isAtBottom: true});
        this.updateReadline();
      },

      rescrollToBottom () {
        if (this.get()._isAtBottom) {
          this.scrollToBottom();
        }
      },

      removeMessage (message) {
        const {messages} = this.get();
        const index = message.arraySearch(messages);
        if (index !== false) {
          messages.splice(index, 1);
          this.set({messages});
        }
      }
    },

    components: {
      LoadingIndicator,
      MessageView
    },

    helpers: {
      moment,
      showTime (time1, time2) {
        if (time2 === undefined) {
          time2 = new Date() / 1000;
        }
        const now = new Date() / 1000;
        if (now - time1 > 6 * 24 * 60 * 60) {
          // More than 6 days ago.
          return (time2 - time1 > 24 * 60 * 60); // 24 hours
        } else if (now - time1 > 24 * 60 * 60) {
          // More than 1 day ago.
          return (time2 - time1 > 4 * 60 * 60); // 4 hours
        } else {
          return (time2 - time1 > 2 * 60 * 60); // 2 hours
        }
      }
    }
  };
</script>
