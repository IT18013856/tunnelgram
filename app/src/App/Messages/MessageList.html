<svelte:window on:resize={handleWindowResize} />
<div class="position-absolute h-100 w-100 pt-3" style="overflow-y: auto; -webkit-overflow-scrolling: touch; overflow-x: hidden;" bind:this={container} on:scroll={handleScroll}>
  {#if _loading}
    <div class="d-flex align-items-center justify-content-center" style="height: 100%;">
      <div style="background-image: url(images/android-chrome-192x192.png); background-size: cover; position: absolute; width: 88px; height: 88px;"></div>
      <LoadingIndicator width="200" height="200" />
    </div>
  {:else}
    {#if _reachedEarliestMessage}
      <ConversationHeader bind:conversation={conversation} />
    {:else}
      <div class="d-flex align-items-center justify-content-center {_loadingEarlierMessages ? '' : 'visibility-hidden'}" style="height: 150px;">
        <div class="col-auto">
          <LoadingIndicator width="50" height="50" />
        </div>
      </div>
    {/if}
    <div class="d-flex flex-column-reverse" bind:this={messageContainer}>
      {#each messages as message, i (message.guid)}
        <div class="d-flex flex-column align-items-start message-box" data-cdate={'' + message.cdate}>
          <MessageView bind:message on:rendered={rescrollToBottom} on:deleted={() => removeMessage(message)} readLineCDate={_showReadline && _initialReadline} showAvatar={i === 0 || messages[i - 1].data.user.guid !== message.data.user.guid} showTime={i < (messages.length - 1) && showTime(messages[i + 1].cdate, message.cdate)}></MessageView>
        </div>
      {/each}
    </div>
    <div class="d-flex flex-column align-items-start">
      {#each conversation.pending as message}
        <MessageView bind:message on:rendered={rescrollToBottom} pending="true" showTime={messages.length && showTime(messages[0].cdate)}></MessageView>
      {/each}
    </div>
  {/if}
</div>

<script>
  import {onMount, onDestroy, beforeUpdate, afterUpdate} from 'svelte';
  import {Nymph, PubSub} from 'nymph-client';
  import Message from '../../Entities/Tunnelgram/Message';
  import ConversationHeader from '../Conversations/ConversationHeader';
  import LoadingIndicator from '../LoadingIndicator';
  import MessageView from './MessageView';
  import ErrHandler from '../../ErrHandler';
  import {user} from '../../stores';

  export let conversation;
  export let messages = [];
  let container;
  let messageContainer;
  let _loading;
  let _disconnected = false;
  let _isAtBottom = true;
  let _showReadline = null;
  let _initialReadline = null;
  let _loadingEarlierMessages = false;
  let _reachedEarliestMessage = false;
  let _scrollToDistanceFromBottom = null;
  let scrollWaitBottom;
  let scrollWaitReadline;
  let scrollToBottomListener;
  let updateReadlineRaf;
  let destroyed = false;
  let subscription;
  const MESSAGE_PAGE_SIZE = 20;
  const onPubSubConnect = () => {
    if (_disconnected) {
      Nymph.getEntities({
        'class': Message.class,
        'sort': 'cdate',
        'reverse': true
      }, {
        'type': '&',
        'ref': ['conversation', conversation.guid],
        'gt': ['cdate', messages.length ? messages[messages.length - 1].cdate : 0]
      }).then(newMessages => {
        messages = [...newMessages, ...messages];
      });
    }
    _disconnected = false;
  };
  const onPubSubDisconnect = () => {
    _disconnected = true;
  };
  const showTime = (time1, time2) => {
    if (time2 === undefined) {
      time2 = (+new Date()) / 1000;
    }
    const now = (+new Date()) / 1000;
    if (now - time1 > 6 * 24 * 60 * 60) {
      // More than 6 days ago.
      return (time2 - time1 > 24 * 60 * 60); // 24 hours
    } else if (now - time1 > 24 * 60 * 60) {
      // More than 1 day ago.
      return (time2 - time1 > 4 * 60 * 60); // 4 hours
    } else {
      return (time2 - time1 > 2 * 60 * 60); // 2 hours
    }
  };

  onMount(() => {
    subscribe();
    _initialReadline = conversation.readline;
    scrollWaitBottom = true;
    scrollWaitReadline = false;

    PubSub.on('connect', onPubSubConnect);
    PubSub.on('disconnect', onPubSubDisconnect);
  });

  beforeUpdate(() => {
    // TODO: can this be moved out of beforeUpdate?
    if (_showReadline === null && _initialReadline !== 0 && messages.length) {
      const visibleReadLine = _initialReadline > 0
        && _initialReadline < messages[0].cdate;
      _showReadline = visibleReadLine;
      if (visibleReadLine) {
        scrollWaitReadline = window.setTimeout(() => {
          scrollWaitReadline = false;
          scrollToReadLine();
        }, 500);
        scrollWaitBottom = false;
      }
    }
  });

  let previousLoading = _loading;
  let previousMessagesLength = messages.length;
  let previousScrollToDistanceFromBottom = _scrollToDistanceFromBottom;
  afterUpdate(() => {
    if ((
        // Scroll to the bottom when the messages are first loaded.
        (previousLoading !== _loading && !_loading && !scrollWaitReadline) ||
        // Scroll to the bottom when new messages come in, if the user is at the bottom and the window is focused.
        (previousMessagesLength !== messages.length && _isAtBottom && !document.hidden && !scrollWaitReadline)
      )) {
      scrollToBottom();
    }

    if (previousScrollToDistanceFromBottom !== _scrollToDistanceFromBottom && _scrollToDistanceFromBottom != null) {
      window.requestAnimationFrame(() => {
        container.scrollTop = container.scrollHeight - _scrollToDistanceFromBottom;
        _scrollToDistanceFromBottom = null;
      });
    }

    // Perform any scrolls that have been waiting.
    if (scrollWaitReadline) {
      window.clearTimeout(scrollWaitReadline);
      scrollWaitReadline = false;
      scrollToReadLine();
    }

    previousLoading = _loading;
    previousMessagesLength = messages.length;
    previousScrollToDistanceFromBottom = _scrollToDistanceFromBottom;
  });

  onDestroy(() => {
    destroyed = true;
    if (subscription) {
      subscription.unsubscribe();
    }

    if (scrollToBottomListener) {
      scrollToBottomListener.cancel();
    }

    PubSub.off('connect', onPubSubConnect);
    PubSub.off('disconnect', onPubSubDisconnect);
  });

  function subscribe () {
    if (subscription) {
      subscription.unsubscribe();
    }

    _loading = true;

    subscription = Nymph.getEntities({
      'class': Message.class,
      'sort': 'cdate',
      'reverse': true,
      'limit': MESSAGE_PAGE_SIZE
    }, {
      'type': '&',
      'ref': ['conversation', conversation.guid]
    }).subscribe(update => {
      if (destroyed) {
        return;
      }
      if (update) {
        if (Array.isArray(update)) {
          if (update.length < MESSAGE_PAGE_SIZE) {
            _reachedEarliestMessage = true;
          }
        }
        PubSub.updateArray(messages, update);
        // Setting _loading needs to go before handleScroll to scroll to the bottom on initial load.
        messages = messages;
        _loading = false;
        createNewReadlineIfNeeded();
        handleScroll();

        if (update.added) {
          // Remove the message from pending messages.
          const ent = update.data;
          for (let i = 0; i < conversation.pending.length; i++) {
            const cur = conversation.pending[i];
            if (ent.data.keys[$user.guid] === cur.data.keys[$user.guid]) {
              conversation.pending.splice(i, 1);
              conversation = conversation;
              break;
            }
          }
        }
      } else {
        _loading = false;
      }
    }, err => {
      ErrHandler(err);
      _loading = false;
    });
  }

  function handleScroll () {
    if (container.scrollTop < 250) {
      loadEarlierMessages();
    }

    setIsAtBottom();
    updateReadline();
  }

  function handleWindowResize () {
    // Scroll to the bottom if the user was at the bottom.
    if (_isAtBottom) {
      scrollToBottom();
    }
  }

  function setIsAtBottom () {
    _isAtBottom = container.scrollTop >= (container.scrollHeight - container.offsetHeight);
  }

  async function loadEarlierMessages () {
    if (_loadingEarlierMessages || _reachedEarliestMessage || _scrollToDistanceFromBottom || scrollWaitReadline || scrollWaitBottom) {
      return;
    }

    if (!messages.length) {
      return;
    }

    _loadingEarlierMessages = true;

    try {
      const earlierMessages = await Nymph.getEntities({
        'class': Message.class,
        'sort': 'cdate',
        'reverse': true,
        'limit': MESSAGE_PAGE_SIZE
      }, {
        'type': '&',
        'ref': ['conversation', conversation.guid],
        'lt': ['cdate', messages[messages.length - 1].cdate]
      });

      if (earlierMessages && earlierMessages.length) {
        messages = [...messages, ...earlierMessages];
        _scrollToDistanceFromBottom = container.scrollHeight - container.scrollTop;
      } else {
        _reachedEarliestMessage = true;
      }
    } catch (e) {
      ErrHandler(e);
    }

    _loadingEarlierMessages = false;
  }

  function updateReadline () {
    // Don't update the readline if the user doesn't have the page open.
    if (document.hidden) {
      return;
    }
    // Update readline on next animation frame (so that the DOM can be updated).
    if (updateReadlineRaf) {
      window.cancelAnimationFrame(updateReadlineRaf);
    }
    updateReadlineRaf = window.requestAnimationFrame(async () => {
      updateReadlineRaf = null;
      if (!messageContainer) {
        return;
      }
      if (conversation.readline !== null) {
        const messageBoxes = messageContainer.querySelectorAll('.message-box[data-cdate]');
        const messageBoxesInViewport = Array.from(messageBoxes).filter(el => {
          const containerTop = container.scrollTop;
          const containerBottom = containerTop + container.clientHeight;
          const elBottom = el.offsetTop + el.offsetHeight;
          return (elBottom + 10 >= containerTop) && (elBottom - 10 <= containerBottom); // 10 pixel buffer.
        });
        if (messageBoxesInViewport.length) {
          const latestReadMessageBox = messageBoxesInViewport[0];
          const updateReadline = JSON.parse(latestReadMessageBox.dataset.cdate);
          if (updateReadline > conversation.readline) {
            await conversation.saveReadline(updateReadline);
            conversation = conversation;
          }
        }
      }
    });
  }

  async function createNewReadlineIfNeeded () {
    if (conversation.readline == null && messages.length) {
      const updateReadline = messages[0].cdate;
      _initialReadline = updateReadline;
      await conversation.saveReadline(updateReadline);
      conversation = conversation;
    }
  }

  function scrollToReadLine () {
    const readlineEl = container.querySelector('.readline');
    if (readlineEl) {
      container.scrollTop = Math.max(0, readlineEl.offsetTop - (container.clientHeight * .5));
      setIsAtBottom();
      updateReadline();
    }
  }

  export function requestScrollToBottom () {
    if (!scrollWaitReadline) {
      scrollToBottom();
    }
  }

  function scrollToBottom () {
    container.scrollTop = container.scrollHeight;
    scrollWaitBottom = false;
    _isAtBottom = true;
    updateReadline();
  }

  function rescrollToBottom () {
    if (_isAtBottom) {
      scrollToBottom();
    }
  }

  function removeMessage (message) {
    const idx = message.arraySearch(messages);
    if (idx !== false) {
      messages.splice(idx, 1);
      messages = messages;
    }
  }
</script>
